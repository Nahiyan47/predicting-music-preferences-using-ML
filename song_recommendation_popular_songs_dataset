# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EfeJYCUnObgpYNk4q_IWrqlP_GdSGTj4
"""

import pandas as pd
import numpy as np

# Load the dataset (updated_song_lyrics.csv)
df = pd.read_csv("updated_song_details.csv")

# Function to convert views to numerical values
def convert_views_to_numerical(views):
    suffixes = {'K': 1000, 'M': 1000000, 'B': 1000000000}
    if views[-1] in suffixes:
        return float(views[:-1]) * suffixes[views[-1]]
    else:
        return float(views)

# Convert youtube_views to numerical format
df['youtube_views_numeric'] = df['youtube_views'].apply(convert_views_to_numerical)

# Define function to calculate similarity scores
def calculate_similarity(song1, song2, weights):
    similarity = 0.0
    for attr in weights:
        if attr == 'author':
            similarity += weights[attr] * (1 if song1[attr] == song2[attr] else 0)
        elif attr == 'emotional_theme':
            similarity += weights[attr] * (1 if song1[attr] == song2[attr] else 0)
        elif attr == 'genre':
            similarity += weights[attr] * (1 if song1[attr] == song2[attr] else 0)
        elif attr == 'youtube_views_numeric':
            similarity += weights[attr] * (1 - np.abs(song1[attr] - song2[attr]) / max(song1[attr], song2[attr]))
        elif attr == 'polarity':
            similarity += weights[attr] * np.abs(song1[attr] - song2[attr])
        elif attr == 'subjectivity':
            similarity += weights[attr] * np.abs(song1[attr] - song2[attr])
    return similarity

# Function to recommend songs based on selected songs
def recommend_songs(selected_songs, all_songs, weights, num_recommendations=5):
    recommendations = []
    selected_song_names = [song['song_name'] for song in selected_songs]

    for idx, song in all_songs.iterrows():
        if song['song_name'] not in selected_song_names:
            similarity_score = sum(calculate_similarity(song, selected_song, weights) for selected_song in selected_songs)
            recommendations.append((song['song_name'], similarity_score, song['author'], song['genre'], song['emotional_theme']))

    recommendations.sort(key=lambda x: x[1], reverse=True)
    return recommendations[:num_recommendations]

# Prompt user to enter the names of three selected songs
selected_songs = []
for i in range(3):
    song_name = input(f"Enter the name of selected song {i+1}: ")
    selected_song_data = df[df['song_name'] == song_name].iloc[0].to_dict()
    selected_songs.append(selected_song_data)
    print(f"Selected Song {i+1}: {song_name} ({selected_song_data['author']}, {selected_song_data['emotional_theme']})")

# Define weights for attributes
weights = {
    'author': 0.4,
    'emotional_theme': 0.3,
    'genre': 0.2,
    'youtube_views_numeric': 0.1,
    'polarity': 0.05,
    'subjectivity': 0.05
}

# Recommend songs based on selected songs and weights
recommended_songs = recommend_songs(selected_songs, df, weights)
print("\nRecommended Songs:")
for song, similarity_score, author, genre, emotional_theme in recommended_songs:
    print(f"{song} ({author}, {genre}, {emotional_theme}) - Similarity Score: {similarity_score}")





